**Context**:
I was tasked with adding a feature to the company's internal billable-days-tracking application.

**The feature**:
The story originally involved a request to be able to generate a report that would display all a project's billable days, and group those billable days by iteration cycle. For context a **project** refers to a contract project in its totality. Each project has many **results**, which are essentially units by which employees can account for strength and days spent working on individual projects. Each project also had at least one **iteration rate**, which refers to the length of a cycle of an iteration. An iteration rate (length) is set upon creating a project, and informs operations teams of how and when to bill clients (i.e., if an iteration rate is 2 weeks, clients will be billed bi-monthly, and the bill will reflect two weeks' worth of work).

**Tricky, unforeseen complications**:

  1.  If the initial iteration rate's effective date doesn't coincide with a project's start date, the project's first and last iterations will be partial. Partial iterations must be denoted as such, and should display any billable days they encapsulate.
  2.  Results may overlap two iterations, in which case a result's billable days must be split and accounted for accurately in each of the two iterations.
  3.  The feature request also specified that admins should be able to change the iteration rate mid-project. That means that billable days that occurred during the course of the first iteration rate should be grouped using the original iteration rate. And any billable days that occurred after a new iteration rate went into effect should be grouped using the new rate. This point was further complicated by the fact that the project's iteration rate should be changeable as many times as the user needs to.

**Solutions**:

  1.  The first challenge was writing a SQL query that would collect all the results that overlapped a particular iteration. Once I had access to those records, I could then deal with paring them down and determining which billable days fell within the given iteration. The final query turned out like this: given an iteration, find all a project's results `where("(start_date - ?) * (? - end_date) > 0", iteration.end_date, iteration.start_date)`.
  2.  The next challenge was building the iterations themselves. Because I new they'd be prone to change, and that the strategy/operations teams may end up retroactively changing the iteration rate for earlier date ranges, it didn't make sense to write iteration data to the database. Instead, I needed to build them as virtual objects with attributes that would only be used to supply values in the end report. To address this need, I created an `IterationFactory` class that would take the project's iteration rates and use their effective dates to split the project timeline into smaller timelines. These timelines could then be processed individually to create iterations based on the rate they had been assigned. Up until the `generate_iterations` method in `IterationFactory`'s public interface, the iterations it created were "raw," and didn't account for billable days that fell outside the total iterations' minimum and maximum start dates and end dates, respectively.
  3. Last, and most unpleasantly, I needed to account for any partial iterations that came at the beginning or end of the project timeline. This involved comparing the project's start date with its first iteration rate's effective date, and accounting for any billable days that fell between the two. The Ruby Enumerable's `step` method, which I used to split up the iteration-rate specific timelines, also often generated a final iteration that exceeded the project's end date. If that was the case, I had to remove the final iteration and create one that did not exceed the project's end date. This process of "sterilization" was sent to the `IterationSterilizer` during the `IterationFactory`'s final step before passing the  iterations off to the `IterationReport` instance.

  **The "Final" Product**:
  Once the `IterationReport` instance received the newly sterilized iterations, its public methods could be given either a single iteration, or an entire collection of iterations, and return the accurate number of billable days for every given iteration. These values were then shunted into a project's `show` template and were available for reference anytime a user visited the page.